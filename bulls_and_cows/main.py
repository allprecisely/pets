"""
Начнем отгадывать. Первые 4 цифры абсолютно не важны: это могут быть 1234 или 4 рандомных
Собственно пусть в начале спросим 0123.
Пользователь может ответить как угодно (парой б к):
0 0; 0 1; 0 2; 0 3; 0 4; 1 0; 1 1; 1 2; 1 3; 2 0; 2 1; 2 2; 3 0; 4 0 - 14 вариантов
если он отвечает любым из вариантов, то мы отбрасываем множество потенциальных
- то есть нужно составить множество потенциальных вариантов - изначально это все 4 значные
числа с неповторяющимися цифрами, которые могут содержать первым числом ноль
всего вариантов 10 * 9 * 8 * 7 = 5040

пусть вариант 0 0:
тогда мы точно знаем, что можно отбросить все числа, содержащие любую из цифр
останется 6 * 5 * 4 * 3 = 360

пусть вариант 0 1:
мы предположим, что 0 есть в числе. при этом 1 2 3 там нет; 0 точно есть и не на первой позиции
6 * 5 * 4 * 3 = 360 вариантов (0 точно в числе в любой из 3 позиций; и остается 6 чисел по 3 позициям)
360 * 4 = 1440 (но при этом это работает для 4 цифр)

пусть 0 2:
предполагаем, что в числе 0 1: тогда 2,3 там нет, и 0, 1 есть но не на своих позициях
6 * 5 * 7 = 210 (7 вариантов расположить 0 и 1 по своим позициям; при этом остается 6 чисел в 2 п)
210 * 6 = 1260 (6 пар можно взять)

0 3:
логика аналогична для 0 2, видим закономерность:
- нужно посчитать сколькими способами можно выбрать С коров из N позиций, причем чтобы они не стояли
на своих изначальных местах - это можно перебором с помощью функции
- нужно посчитать, сколько остается цифр из А с учетом C коров, и сколькими способами их можно расставить
на N - C позициях
- сколько пар из С коров можно составить

можно все легче, перебором
например, 0123 - 0 1
мб 0123? нет, т.к. коров и быков недостаточно. и так проверяем все числа, обновляя таблицу


теперь перейдем к тому, как же определить, что именно спросить:
для каждого существующего варианта по идее нужно узнать, какие ответы возможны, и сколько после них
останется вариантов. самый перспективный нас и заинтересует
например, после того, как нам ответили на 0123 - 0 1; у нас остается 1440 вариантов
- мы знаем, что если мы спросим снова 0123, то в принципе мы не улучшим ситуацию
- 0124: этот вариант возможен, и он нам может дать следующие ответы
0 0; 0 1; 0 2; 1 0; 1 1
при получении каждого ответа у нас сузится количество возможных ответов
0 0 - 180
0 1 - ... и т.д.
в результате мы смотрим на медианное значение в случае больше 2 возможностей (среднее при 2, 1)
и определяем какое число следующее
- сложность: как определить количество вариантов?
- сложность: 456789 - в данном случае равнозначные цифры, и нет смысла проверять 0125 если 0124 проверено

можно предположить (сходу не знаю так ли это), что при одинаковых возможностях числа равнозначны
(буду отталкиваться от этого предположения пока)

в принципе можно сделать некрасивый дикт с ключами как тапл возможностей, а значения - сет чисел
этот дикт нужно переформировывать при каждом вопросе
кажется не очень дорого, но как забрать возможные ответы...
можно пойти дорогим вариантом, проверяя все ответы, и исключать те, которые оставляют 0 вариантов
(собственно при 0123 - 1 1: уже неприятно определять 0124: 0 1; 0 2; 1 0; 1 1; 1 2; 2 1 - логика
сходу не улавливается; но можно все же в кэше сохранять возможные варианты - их будет становится
же меньше только)
в общем тогда для каждого числа храним список возможных значений
при каждом вопросе проходимся снова по всей таблице, и удаляем лишнее
при этом инициализируем 2 структуры: ключи, которые будем изучать, и таплы из списка значений
если следующее значение из таблицы есть в структуре таплов, то скипаем значение


"""
from typing import List, Optional

ALNUM = '0123456789'
POSSIBLE_VARIANTS: List[str] = []

POSSIBLE_ANSWERS = []


def generate_variants(n: int, current_prefix: str = '') -> List[str]:
    result = []
    for i in ALNUM:
        if i in current_prefix:
            continue
        if len(current_prefix) < n - 1:
            result.extend(generate_variants(n, current_prefix + i))
        else:
            result.append(current_prefix + i)
    return result


def update_table_after_guess(cows: int, bulls: int, guess: str, table: List[str]) -> List[str]:
    new_table = []
    for variant in table:
        c, b = cows, bulls
        for i in range(len(guess)):
            if guess[i] == variant[i]:
                b -= 1
            elif guess[i] in variant:
                c -= 1
            if c < 0 or b < 0:
                break
        if not (c or b):
            new_table.append(variant)
    return new_table


def check_if_answer_possible(pair: tuple, answer: str, table: List[str]) -> bool:
    new_table = []
    for variant in table:
        c, b = pair
        for i in range(len(answer)):
            if answer[i] == variant[i]:
                b -= 1
            elif answer[i] in variant:
                c -= 1
            if c < 0 or b < 0:
                break
        if not (c or b):
            new_table.append(variant)
    return bool(new_table)


def update_possible_answers(possible_answers, table) -> List[str]:
    uniq_keys = []
    for key, answers in possible_answers.items():
        # пока слишком сложно
        pass



def main():
    table = generate_variants(4)
    possible_answers = {
        key: [
            (0, 0), (0, 1), (0, 2), (0, 3), (0, 4),
            (1, 0), (1, 1), (1, 2), (1, 3),
            (2, 0), (2, 1), (2, 2),
            (3, 0),
            (4, 0),
        ] for key in table,
    }
    while True:
        bulls, cows = map(int, input('bulls cows: ').split())



# def check_guess(guess: str, remained_variants: List[str]) -> bool:

